/**
 * 希尔排序
 * <p>
 * 希尔排序的思想是使数组中任意间隔为 h 的元素都是有序的。这样的数组被称为 h 有序数组。换
 * 句话说，一个 h 有序数组就是 h 个互相独立的有序数组编织在一起组成的一个数组
 * <p>
 * 实现希尔排序的一种方法是对于每个 h，用插入排序将 h 个子数组独立地排序。
 * 但因为子数组 是相互独立的，一个更简单的方法是在 h- 子数组中将每个元素交换到比它大的元素之前去(将比它 大的元素向右移动一格)。
 * 只需要在插入排序的代码中将移动元素的距离由 1 改为 h 即可。这样，希 尔排序的实现就转化为了一个类似于插入排序但使用不同增量的过程。
 * <p>
 * 希尔排序更高效的原因是它权衡了子数组的规模和有序性。
 * 排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。
 * 子数组部分有序的程度取决于递增 序列的选择。透彻理解希尔排序的性能至今仍然是一项挑战。
 * <p>
 * 在插入排序中加入一个外循环来将 h 按照递增序列递减，我们就能得到这个 简洁的希尔排序。
 * 增幅 h 的初始值是数组长度乘以一个常数因子，最小为 1。
 *
 * @author fxm
 * @date 2023/7/20 9:48 上午
 */
public class ShellSort implements Sort {
    @Override
    public void sort(int[] a) {
        int N = a.length;
        // h有序数组
        int h = 1;
        while (h < (N / 3)) {
            h = 3 * h + 1;
        }
        while (h >= 1) {
            // 将数组变为h有序
            for (int i = h; i < N; i++) {
                // 将a[i]插入到a[i-h], a[i-2*h], a[i-3*h]... 之中
                for (int j = i; j >= h && Sort.less(a[j], a[j - h]); j -= h) {
                    Sort.exchange(a, j, j - h);
                }
            }
            h = h / 3;
        }
    }

    public static void main(String[] args) {
        int[] a = {3, 2, 1, 5, 4, 9, 6};
        new ShellSort().sort(a);
    }
}
